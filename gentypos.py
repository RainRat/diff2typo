import sys
import argparse
import yaml
import logging
from collections import defaultdict
from tqdm import tqdm  # For progress bars; install via `pip install tqdm`
import os

def get_adjacent_keys(include_diagonals=True):
    """
    Returns a dictionary of adjacent keys on a QWERTY keyboard.
    Can include diagonally adjacent keys based on the 'include_diagonals' flag.

    Args:
        include_diagonals (bool): Whether to include diagonally adjacent keys.

    Returns:
        dict: A mapping from each character to its adjacent characters.
    """
    keyboard = [
        'qwertyuiop',
        'asdfghjkl',
        'zxcvbnm',
    ]

    # Map each character to its (row, column) coordinate for quick lookup
    coords = {}
    for r, row in enumerate(keyboard):
        for c, ch in enumerate(row):
            coords[ch] = (r, c)

    adjacent = {ch: set() for ch in coords}

    for ch, (r, c) in coords.items():
        # Examine neighbouring positions within a 1-key radius
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue  # Skip the key itself

                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= len(keyboard):
                    continue
                if nc < 0 or nc >= len(keyboard[nr]):
                    continue

                # Exclude diagonal keys if requested
                if not include_diagonals and dr != 0 and dc != 0:
                    continue

                adjacent_char = keyboard[nr][nc]
                adjacent[ch].add(adjacent_char)

    return adjacent


def load_custom_substitutions(custom_subs):
    """
    Load custom substitution rules from a dictionary.

    Args:
        custom_subs (dict): Dictionary containing custom substitution rules.

    Returns:
        dict: A dictionary with characters as keys and sets of substitution characters as values.
    """
    if not custom_subs:
        return {}
    # Ensure all keys and values are lowercase
    substitutions = {k.lower(): set(vv.lower() for vv in v) for k, v in custom_subs.items()}
    return substitutions


def generate_typos_by_replacement(word, adjacent_keys, custom_subs=None,
                                  use_adjacent=True, use_custom=True):
    """
    Generate typos by replacing each character with its adjacent keys and/or custom substitutions.

    Args:
        word (str): The input word.
        adjacent_keys (dict): Mapping of each character to its adjacent keys.
        custom_subs (dict, optional): Custom substitution rules.
        use_adjacent (bool): Whether to include adjacent key substitutions.
        use_custom (bool): Whether to include custom substitutions.

    Returns:
        set: A set of typo variations generated by replacement.
    """
    typos = set()

    for i, char in enumerate(word):
        replacement_chars = set()

        # Adjacent key replacements
        if use_adjacent and char in adjacent_keys:
            replacement_chars.update(adjacent_keys[char])

        # Custom substitutions
        if use_custom and custom_subs and char in custom_subs:
            replacement_chars.update(custom_subs[char])

        for replace_char in replacement_chars:
            typo = word[:i] + replace_char + word[i+1:]
            typos.add(typo)

    return typos


def generate_variations(word, typo_types, transposition_distance=1):
    """
    Generate deletion and transposition typos.

    Args:
        word (str): The input word.
        typo_types (dict): Dictionary indicating which typo types to apply.

    Returns:
        set: A set of typo variations from deletion and transposition.
    """
    variations = set()

    # Deletion
    if typo_types.get('deletion', False):
        for i in range(len(word)):
            # Don't remove 's' or 'd' from the end of the word
            if i == len(word) - 1 and word[i] in {'s', 'd'}:
                continue
            variation = word[:i] + word[i + 1:]
            variations.add(variation)

    # Transposition
    if typo_types.get('transposition', False):
        distance = max(1, transposition_distance)
        for i in range(len(word) - distance):
            if word[i] == word[i + distance]:
                continue  # Don't swap identical letters
            # Swap characters that are 'distance' apart
            middle = word[i + 1:i + distance]
            variation = word[:i] + word[i + distance] + middle + word[i] + word[i + distance + 1:]
            variations.add(variation)

    return variations


def generate_typos_by_duplication(word, typo_types):
    """
    Generate typos by duplicating each character in the word.

    Args:
        word (str): The input word.
        typo_types (dict): Dictionary indicating which typo types to apply.

    Returns:
        set: A set of typo variations generated by duplication.
    """
    typos = set()

    if typo_types.get('duplication', False):
        for i in range(len(word)):
            duplicated_char = word[i]
            typo = word[:i+1] + duplicated_char + word[i+1:]
            typos.add(typo)

    return typos


def generate_all_typos(word, adjacent_keys, custom_subs, typo_types,
                       transposition_distance=1, use_adjacent=True,
                       use_custom=True):
    """
    Generate all possible typos for a given word using selected typo types.

    Args:
        word (str): The input word.
        adjacent_keys (dict): Mapping of each character to its adjacent keys.
        custom_subs (dict): Custom substitution rules.
        typo_types (dict): Dictionary indicating which typo types to apply.
        transposition_distance (int): Distance between letters to swap for transposition typos.
        use_adjacent (bool): Whether to include adjacent key substitutions.
        use_custom (bool): Whether to include custom substitutions.

    Returns:
        set: A set of all unique typo variations.
    """
    typos = set()

    # Deletion and Transposition
    typos.update(generate_variations(word, typo_types, transposition_distance))

    # Replacement
    if typo_types.get('replacement', False):
        typos.update(
            generate_typos_by_replacement(
                word,
                adjacent_keys,
                custom_subs,
                use_adjacent,
                use_custom,
            )
        )

    # Duplication
    if typo_types.get('duplication', False):
        typos.update(generate_typos_by_duplication(word, typo_types))

    return typos


def load_file(file_path):
    """
    Generic function to load words from a file into a set.
    Filters out non-ASCII words and converts them to lowercase.

    Args:
        file_path (str): Path to the file containing words.

    Returns:
        set: A set of cleaned words.
    """
    try:
        words = set()
        with open(file_path, 'r', encoding='utf-8') as file:
            for line in file:
                line = line.strip()
                if line and all(ord(c) < 128 for c in line):
                    words.add(line.lower())
        logging.debug(f"Loaded {len(words)} unique words from '{file_path}'.")
        return words
    except FileNotFoundError:
        logging.error(f"File '{file_path}' not found.")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Error reading '{file_path}': {e}")
        sys.exit(1)


def parse_yaml_config(config_path):
    """
    Parse the YAML configuration file.

    Args:
        config_path (str): Path to the YAML configuration file.

    Returns:
        dict: Parsed configuration.
    """
    try:
        with open(config_path, 'r', encoding='utf-8') as file:
            config = yaml.safe_load(file)
            logging.debug(f"Parsed YAML configuration from '{config_path}'.")
            return config
    except FileNotFoundError:
        logging.error(f"Configuration file '{config_path}' not found.")
        sys.exit(1)
    except yaml.YAMLError as e:
        logging.error(f"Error parsing YAML file '{config_path}': {e}")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Error reading '{config_path}': {e}")
        sys.exit(1)


def validate_config(config):
    """
    Validate the YAML configuration to ensure all required fields are present.

    Args:
        config (dict): Parsed YAML configuration.
    """
    required_fields = ['input_file', 'dictionary_file', 'output_file', 'output_format']
    for field in required_fields:
        if field not in config:
            logging.error(f"Missing required configuration field: '{field}'")
            sys.exit(1)
    
    # Validate typo_types
    if 'typo_types' in config:
        expected_typo_types = {'deletion', 'transposition', 'replacement', 'duplication'}
        provided_typo_types = set(config['typo_types'].keys())
        missing_typo_types = expected_typo_types - provided_typo_types
        if missing_typo_types:
            logging.warning(f"Missing typo types in configuration: {missing_typo_types}. Setting them to default (True).")
            for typo_type in missing_typo_types:
                config['typo_types'][typo_type] = True
    else:
        # Set all typo types to True by default if not specified
        config['typo_types'] = {'deletion': True, 'transposition': True, 'replacement': True, 'duplication': True}
        logging.info("No typo_types specified in configuration. Defaulting all to True.")
    
    # Validate word_length
    if 'word_length' in config:
        if 'min_length' not in config['word_length']:
            logging.warning("Missing 'min_length' in 'word_length'. Setting to default (8).")
            config['word_length']['min_length'] = 8
        if 'max_length' not in config['word_length']:
            config['word_length']['max_length'] = None  # No maximum
    else:
        config['word_length'] = {'min_length': 8, 'max_length': None}
        logging.info("No word_length specified in configuration. Setting 'min_length' to 8 and no 'max_length'.")


def format_typos(typo_to_correct_word, output_format):
    """
    Formats the typos based on the specified output format.

    Args:
        typo_to_correct_word (dict): Mapping from typo to correct word.
        output_format (str): Desired output format ('arrow', 'csv', 'table', 'list').

    Returns:
        list: Formatted list of typo strings.
    """
    formatted = []
    for typo, correct_word in typo_to_correct_word.items():
        if output_format == 'arrow':
            formatted.append(f"{typo} -> {correct_word}")
        elif output_format == 'csv':
            formatted.append(f"{typo},{correct_word}")
        elif output_format == 'table':
            formatted.append(f'{typo} = "{correct_word}"')
        elif output_format == 'list':
            formatted.append(f"{typo}")
        else:
            # Default to arrow if unknown format
            formatted.append(f"{typo} -> {correct_word}")
    return formatted


def main():
    """
    Main function to generate synthetic typos and save them to a file based on YAML configuration.
    """
    # Configure logging
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description="Synthetic Typo Generator: Generate synthetic typos for a list of words based on YAML configuration."
    )
    parser.add_argument(
        '-c', '--config',
        type=str,
        default="gentypos.yaml",
        help="Path to the YAML configuration file (default: gentypos.yaml)"
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help="Enable verbose output."
    )
    args = parser.parse_args()

    # Set logging level based on verbose flag
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        logging.debug("Verbose mode enabled.")

    # Load configuration
    config = parse_yaml_config(args.config)

    # Validate configuration
    validate_config(config)

    # Extract configuration parameters
    input_file = config.get('input_file', 'wordlist_small.txt')
    dictionary_file = config.get('dictionary_file', 'wordlist_large.txt')
    output_file = config.get('output_file', 'typos_mega.toml')
    output_format = config.get('output_format', 'table').lower()

    # Validate output format
    valid_formats = {'arrow', 'csv', 'table', 'list'}
    if output_format not in valid_formats:
        logging.warning(f"Unknown output format '{output_format}'. Defaulting to 'arrow'.")
        output_format = 'arrow'

    typo_types = config.get(
        'typo_types',
        {'deletion': True, 'transposition': True, 'replacement': True, 'duplication': True},
    )
    replacement_options = config.get(
        'replacement_options',
        {
            'include_diagonals': True,
            'enable_adjacent_substitutions': True,
            'enable_custom_substitutions': True,
        },
    )
    include_diagonals = replacement_options.get('include_diagonals', True)
    enable_adjacent_substitutions = replacement_options.get(
        'enable_adjacent_substitutions', True
    )
    enable_custom_substitutions = replacement_options.get(
        'enable_custom_substitutions', True
    )

    transposition_options = config.get('transposition_options', {'distance': 1})
    transposition_distance = transposition_options.get('distance', 1)

    # How many times to repeat typo generation, stacking modifications
    repeat_modifications = int(config.get('repeat_modifications', 1))
    if repeat_modifications < 1:
        repeat_modifications = 1

    custom_subs = (
        load_custom_substitutions(config.get('custom_substitutions', {}))
        if enable_custom_substitutions
        else {}
    )

    word_length = config.get('word_length', {'min_length': 8, 'max_length': None})
    min_length = word_length.get('min_length', 8)
    max_length = word_length.get('max_length', None)

    # Load words and dictionary using the modified load_file function
    logging.info("Loading wordlist (small dictionary)...")
    word_set = load_file(input_file)
    word_list = list(word_set)  # Convert set to list if needed
    logging.info(f"Loaded {len(word_list)} words from the small dictionary ('{input_file}').")

    logging.info("Loading dictionary (large dictionary)...")
    allwords = load_file(dictionary_file)  # Remains a set
    logging.info(f"Loaded {len(allwords)} words from the large dictionary ('{dictionary_file}').")

    # Load custom substitutions
    logging.info("Loading custom substitutions...")
    if not enable_custom_substitutions:
        logging.info("Custom substitutions disabled.")
    elif custom_subs:
        total_custom_entries = len(custom_subs)
        total_custom_replacements = sum(len(v) for v in custom_subs.values())
        logging.info(
            f"Loaded {total_custom_entries} custom substitution entries with a total of {total_custom_replacements} replacements."
        )
    else:
        logging.info("No custom substitutions loaded.")

    # Get adjacent keys
    if enable_adjacent_substitutions:
        logging.info("Generating adjacent keys mapping...")
        adjacent_keys = get_adjacent_keys(include_diagonals)
        total_adjacent_mappings = len(adjacent_keys)

        # Calculate total non-reflexive adjacent substitutions (a->s is different from s->a)
        adjacent_substitutions = set()
        for char, adj_set in adjacent_keys.items():
            for adj_char in adj_set:
                adjacent_substitutions.add((char, adj_char))
        total_adjacent_substitutions = len(adjacent_substitutions)
        logging.info(
            f"Generated adjacent keys for {total_adjacent_mappings} characters with {total_adjacent_substitutions} unique adjacent substitutions (non-reflexive)."
        )
    else:
        adjacent_keys = {}
        logging.info("Adjacent substitutions disabled.")

    # Generate typos
    logging.info("Generating synthetic typos...")
    typo_to_correct_word = defaultdict(list)  # Using defaultdict to handle multiple correct words for the same typo

    for word in tqdm(word_list, desc="Processing words"):
        word_len = len(word)
        if word_len < min_length:
            continue
        if max_length and word_len > max_length:
            continue

        typos_current = {word}
        accumulated_typos = set()
        for _ in range(repeat_modifications):
            new_typos = set()
            for base_word in typos_current:
                new_typos.update(
                    generate_all_typos(
                        base_word,
                        adjacent_keys,
                        custom_subs,
                        typo_types,
                        transposition_distance,
                        enable_adjacent_substitutions,
                        enable_custom_substitutions,
                    )
                )
            accumulated_typos.update(new_typos)
            typos_current = new_typos
        for typo in accumulated_typos:
            typo_to_correct_word[typo].append(word)

    total_typos_generated = len(typo_to_correct_word)
    logging.info(f"Generated {total_typos_generated} unique synthetic typos before filtering.")

    # Centralized Filtering: Remove typos that are in the large dictionary
    logging.info("Filtering typos against the large dictionary...")
    filtered_typo_to_correct_word = {}
    filtered_typos_count = 0

    for typo, correct_words in typo_to_correct_word.items():
        if typo in allwords:
            filtered_typos_count += 1
            logging.debug(f"Filtered out typo '{typo}' as it exists in the large dictionary.")
            continue
        # If multiple correct words map to the same typo, join them with commas
        filtered_typo_to_correct_word[typo] = ', '.join(correct_words)

    final_typo_count = len(filtered_typo_to_correct_word)
    logging.info(f"After filtering, {final_typo_count} typos remain (filtered out {filtered_typos_count} typos).")

    # Sort typos for consistency
    sorted_typos = sorted(filtered_typo_to_correct_word.items())

    # Convert sorted typos back to a dictionary
    sorted_typo_dict = dict(sorted_typos)

    # Format typos based on the selected output format
    logging.info(f"Formatting typos in '{output_format}' format...")
    formatted_typos = format_typos(sorted_typo_dict, output_format)

    # Write to output file
    try:
        with open(output_file, 'w', encoding='utf-8') as file:
            if output_format == 'table':
                # If table format is used, format it as a typos.toml file
                file.write("[default.extend-words]\n")
                for typo in formatted_typos:
                    file.write(f"{typo}\n")
            else:
                for typo in formatted_typos:
                    file.write(f"{typo}\n")
        logging.info(f"Successfully generated {len(formatted_typos)} synthetic typos and saved to '{output_file}'.")
    except Exception as e:
        logging.error(f"Error writing to '{output_file}': {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
