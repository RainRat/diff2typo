import sys
import argparse
import yaml
import logging
from collections import defaultdict
from tqdm import tqdm  # For progress bars; install via `pip install tqdm`
import os

def get_adjacent_keys(include_diagonals=True):
    """
    Returns a dictionary of adjacent keys on a QWERTY keyboard.
    Can include diagonally adjacent keys based on the 'include_diagonals' flag.

    Args:
        include_diagonals (bool): Whether to include diagonally adjacent keys.

    Returns:
        dict: A mapping from each character to its adjacent characters.
    """
    keyboard = [
        'qwertyuiop',
        'asdfghjkl',
        'zxcvbnm'
    ]

    adjacent = {}
    for row_idx, row in enumerate(keyboard):
        for char_idx, char in enumerate(row):
            adjacent[char] = set()

            # Same row adjacents
            if char_idx > 0:
                adjacent[char].add(row[char_idx - 1])
            if char_idx < len(row) - 1:
                adjacent[char].add(row[char_idx + 1])

            # Adjacent rows
            for other_row_idx, other_row in enumerate(keyboard):
                if abs(other_row_idx - row_idx) == 1:
                    # Determine the range of adjacent keys in the other row
                    start_idx = max(0, char_idx - 1)
                    end_idx = min(len(other_row), char_idx + 2)
                    for adj_char_idx in range(start_idx, end_idx):
                        adjacent_char = other_row[adj_char_idx]
                        adjacent[char].add(adjacent_char)

            if not include_diagonals:
                # Filter adjacent keys from other rows to include only those directly above/below
                direct_adjacent = set()
                for adj_char in list(adjacent[char]):
                    # Find row and column of the adjacent character
                    for r_idx, r in enumerate(keyboard):
                        if adj_char in r:
                            adj_row = r_idx
                            adj_col = r.index(adj_char)
                            break
                    # Direct adjacency: same column
                    if adj_col == char_idx:
                        direct_adjacent.add(adj_char)
                # Retain same-row adjacents and direct adjacents from other rows
                same_row_adjacent = set()
                if char_idx > 0:
                    same_row_adjacent.add(row[char_idx - 1])
                if char_idx < len(row) - 1:
                    same_row_adjacent.add(row[char_idx + 1])
                adjacent[char] = same_row_adjacent.union(direct_adjacent)

    return adjacent


def load_custom_substitutions(custom_subs):
    """
    Load custom substitution rules from a dictionary.

    Args:
        custom_subs (dict): Dictionary containing custom substitution rules.

    Returns:
        dict: A dictionary with characters as keys and sets of substitution characters as values.
    """
    if not custom_subs:
        return {}
    # Ensure all keys and values are lowercase
    print (custom_subs)
    substitutions = {k.lower(): set(vv.lower() for vv in v) for k, v in custom_subs.items()}
    return substitutions


def generate_typos_by_replacement(word, adjacent_keys, custom_subs=None):
    """
    Generate typos by replacing each character with its adjacent keys and/or custom substitutions.

    Args:
        word (str): The input word.
        adjacent_keys (dict): Mapping of each character to its adjacent keys.
        custom_subs (dict, optional): Custom substitution rules.

    Returns:
        set: A set of typo variations generated by replacement.
    """
    typos = set()

    for i, char in enumerate(word):
        replacement_chars = set()

        # Adjacent key replacements
        if char in adjacent_keys:
            replacement_chars.update(adjacent_keys[char])

        # Custom substitutions
        if custom_subs and char in custom_subs:
            replacement_chars.update(custom_subs[char])

        for replace_char in replacement_chars:
            typo = word[:i] + replace_char + word[i+1:]
            typos.add(typo)

    return typos


def generate_variations(word, typo_types):
    """
    Generate deletion and transposition typos.

    Args:
        word (str): The input word.
        typo_types (dict): Dictionary indicating which typo types to apply.

    Returns:
        set: A set of typo variations from deletion and transposition.
    """
    variations = set()

    # Deletion
    if typo_types.get('deletion', False):
        for i in range(len(word)):
            # Don't remove 's' or 'd' from the end of the word
            if i == len(word) - 1 and word[i] in {'s', 'd'}:
                continue
            variation = word[:i] + word[i + 1:]
            variations.add(variation)

    # Transposition
    if typo_types.get('transposition', False):
        for i in range(len(word) - 1):
            if word[i] == word[i + 1]:
                continue  # Don't swap identical letters
            variation = word[:i] + word[i + 1] + word[i] + word[i + 2:]
            variations.add(variation)

    return variations


def generate_typos_by_duplication(word, typo_types):
    """
    Generate typos by duplicating each character in the word.

    Args:
        word (str): The input word.
        typo_types (dict): Dictionary indicating which typo types to apply.

    Returns:
        set: A set of typo variations generated by duplication.
    """
    typos = set()

    if typo_types.get('duplication', False):
        for i in range(len(word)):
            duplicated_char = word[i]
            typo = word[:i+1] + duplicated_char + word[i+1:]
            typos.add(typo)

    return typos


def generate_all_typos(word, adjacent_keys, custom_subs, typo_types):
    """
    Generate all possible typos for a given word using selected typo types.

    Args:
        word (str): The input word.
        adjacent_keys (dict): Mapping of each character to its adjacent keys.
        custom_subs (dict): Custom substitution rules.
        typo_types (dict): Dictionary indicating which typo types to apply.

    Returns:
        set: A set of all unique typo variations.
    """
    typos = set()

    # Deletion and Transposition
    typos.update(generate_variations(word, typo_types))

    # Replacement
    if typo_types.get('replacement', False):
        typos.update(generate_typos_by_replacement(word, adjacent_keys, custom_subs))

    # Duplication
    if typo_types.get('duplication', False):
        typos.update(generate_typos_by_duplication(word, typo_types))

    return typos


def load_file(file_path):
    """
    Generic function to load words from a file into a set.
    Filters out non-ASCII words and converts them to lowercase.

    Args:
        file_path (str): Path to the file containing words.

    Returns:
        set: A set of cleaned words.
    """
    try:
        words = set()
        with open(file_path, 'r', encoding='utf-8') as file:
            for line in file:
                line = line.strip()
                if line and all(ord(c) < 128 for c in line):
                    words.add(line.lower())
        logging.debug(f"Loaded {len(words)} unique words from '{file_path}'.")
        return words
    except FileNotFoundError:
        logging.error(f"File '{file_path}' not found.")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Error reading '{file_path}': {e}")
        sys.exit(1)


def parse_yaml_config(config_path):
    """
    Parse the YAML configuration file.

    Args:
        config_path (str): Path to the YAML configuration file.

    Returns:
        dict: Parsed configuration.
    """
    try:
        with open(config_path, 'r', encoding='utf-8') as file:
            config = yaml.safe_load(file)
            logging.debug(f"Parsed YAML configuration from '{config_path}'.")
            return config
    except FileNotFoundError:
        logging.error(f"Configuration file '{config_path}' not found.")
        sys.exit(1)
    except yaml.YAMLError as e:
        logging.error(f"Error parsing YAML file '{config_path}': {e}")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Error reading '{config_path}': {e}")
        sys.exit(1)


def validate_config(config):
    """
    Validate the YAML configuration to ensure all required fields are present.

    Args:
        config (dict): Parsed YAML configuration.
    """
    required_fields = ['input_file', 'dictionary_file', 'output_file', 'output_format']
    for field in required_fields:
        if field not in config:
            logging.error(f"Missing required configuration field: '{field}'")
            sys.exit(1)
    
    # Validate typo_types
    if 'typo_types' in config:
        expected_typo_types = {'deletion', 'transposition', 'replacement', 'duplication'}
        provided_typo_types = set(config['typo_types'].keys())
        missing_typo_types = expected_typo_types - provided_typo_types
        if missing_typo_types:
            logging.warning(f"Missing typo types in configuration: {missing_typo_types}. Setting them to default (True).")
            for typo_type in missing_typo_types:
                config['typo_types'][typo_type] = True
    else:
        # Set all typo types to True by default if not specified
        config['typo_types'] = {'deletion': True, 'transposition': True, 'replacement': True, 'duplication': True}
        logging.info("No typo_types specified in configuration. Defaulting all to True.")
    
    # Validate word_length
    if 'word_length' in config:
        if 'min_length' not in config['word_length']:
            logging.warning("Missing 'min_length' in 'word_length'. Setting to default (8).")
            config['word_length']['min_length'] = 8
        if 'max_length' not in config['word_length']:
            config['word_length']['max_length'] = None  # No maximum
    else:
        config['word_length'] = {'min_length': 8, 'max_length': None}
        logging.info("No word_length specified in configuration. Setting 'min_length' to 8 and no 'max_length'.")


def format_typos(typo_to_correct_word, output_format):
    """
    Formats the typos based on the specified output format.

    Args:
        typo_to_correct_word (dict): Mapping from typo to correct word.
        output_format (str): Desired output format ('arrow', 'csv', 'table', 'list').

    Returns:
        list: Formatted list of typo strings.
    """
    formatted = []
    for typo, correct_word in typo_to_correct_word.items():
        if output_format == 'arrow':
            formatted.append(f"{typo} -> {correct_word}")
        elif output_format == 'csv':
            formatted.append(f"{typo},{correct_word}")
        elif output_format == 'table':
            formatted.append(f'{typo} = "{correct_word}"')
        elif output_format == 'list':
            formatted.append(f"{typo}")
        else:
            # Default to arrow if unknown format
            formatted.append(f"{typo} -> {correct_word}")
    return formatted


def main():
    """
    Main function to generate synthetic typos and save them to a file based on YAML configuration.
    """
    # Configure logging
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description="Synthetic Typo Generator: Generate synthetic typos for a list of words based on YAML configuration."
    )
    parser.add_argument(
        '-c', '--config',
        type=str,
        default="gentypos.yaml",
        help="Path to the YAML configuration file (default: gentypos.yaml)"
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help="Enable verbose output."
    )
    args = parser.parse_args()

    # Set logging level based on verbose flag
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        logging.debug("Verbose mode enabled.")

    # Load configuration
    config = parse_yaml_config(args.config)

    # Validate configuration
    validate_config(config)

    # Extract configuration parameters
    input_file = config.get('input_file', 'wordlist_small.txt')
    dictionary_file = config.get('dictionary_file', 'wordlist_large.txt')
    output_file = config.get('output_file', 'typos_mega.toml')
    output_format = config.get('output_format', 'table').lower()

    # Validate output format
    valid_formats = {'arrow', 'csv', 'table', 'list'}
    if output_format not in valid_formats:
        logging.warning(f"Unknown output format '{output_format}'. Defaulting to 'arrow'.")
        output_format = 'arrow'

    typo_types = config.get('typo_types', {'deletion': True, 'transposition': True, 'replacement': True, 'duplication': True})
    replacement_options = config.get('replacement_options', {'include_diagonals': True})
    include_diagonals = replacement_options.get('include_diagonals', True)

    custom_subs = load_custom_substitutions(config.get('custom_substitutions', {}))

    word_length = config.get('word_length', {'min_length': 8, 'max_length': None})
    min_length = word_length.get('min_length', 8)
    max_length = word_length.get('max_length', None)

    # Load words and dictionary using the modified load_file function
    logging.info("Loading wordlist (small dictionary)...")
    word_set = load_file(input_file)
    word_list = list(word_set)  # Convert set to list if needed
    logging.info(f"Loaded {len(word_list)} words from the small dictionary ('{input_file}').")

    logging.info("Loading dictionary (large dictionary)...")
    allwords = load_file(dictionary_file)  # Remains a set
    logging.info(f"Loaded {len(allwords)} words from the large dictionary ('{dictionary_file}').")

    # Load custom substitutions
    logging.info("Loading custom substitutions...")
    if custom_subs:
        total_custom_entries = len(custom_subs)
        total_custom_replacements = sum(len(v) for v in custom_subs.values())
        logging.info(f"Loaded {total_custom_entries} custom substitution entries with a total of {total_custom_replacements} replacements.")
    else:
        logging.info("No custom substitutions loaded.")

    # Get adjacent keys
    logging.info("Generating adjacent keys mapping...")
    adjacent_keys = get_adjacent_keys(include_diagonals)
    total_adjacent_mappings = len(adjacent_keys)

    # Calculate total non-reflexive adjacent substitutions (a->s is different from s->a)
    adjacent_substitutions = set()
    for char, adj_set in adjacent_keys.items():
        for adj_char in adj_set:
            adjacent_substitutions.add((char, adj_char))
    total_adjacent_substitutions = len(adjacent_substitutions)
    logging.info(f"Generated adjacent keys for {total_adjacent_mappings} characters with {total_adjacent_substitutions} unique adjacent substitutions (non-reflexive).")

    # Generate typos
    logging.info("Generating synthetic typos...")
    typo_to_correct_word = defaultdict(list)  # Using defaultdict to handle multiple correct words for the same typo

    for word in tqdm(word_list, desc="Processing words"):
        word_len = len(word)
        if word_len < min_length:
            continue
        if max_length and word_len > max_length:
            continue

        typos = generate_all_typos(word, adjacent_keys, custom_subs, typo_types)
        for typo in typos:
            typo_to_correct_word[typo].append(word)

    total_typos_generated = len(typo_to_correct_word)
    logging.info(f"Generated {total_typos_generated} unique synthetic typos before filtering.")

    # Centralized Filtering: Remove typos that are in the large dictionary
    logging.info("Filtering typos against the large dictionary...")
    filtered_typo_to_correct_word = {}
    filtered_typos_count = 0

    for typo, correct_words in typo_to_correct_word.items():
        if typo in allwords:
            filtered_typos_count += 1
            logging.debug(f"Filtered out typo '{typo}' as it exists in the large dictionary.")
            continue
        # If multiple correct words map to the same typo, join them with commas
        filtered_typo_to_correct_word[typo] = ', '.join(correct_words)

    final_typo_count = len(filtered_typo_to_correct_word)
    logging.info(f"After filtering, {final_typo_count} typos remain (filtered out {filtered_typos_count} typos).")

    # Sort typos for consistency
    sorted_typos = sorted(filtered_typo_to_correct_word.items())

    # Convert sorted typos back to a dictionary
    sorted_typo_dict = dict(sorted_typos)

    # Format typos based on the selected output format
    logging.info(f"Formatting typos in '{output_format}' format...")
    formatted_typos = format_typos(sorted_typo_dict, output_format)

    # Write to output file
    try:
        with open(output_file, 'w', encoding='utf-8') as file:
            if output_format == 'table':
                # If table format is used, format it as a typos.toml file
                file.write("[default.extend-words]\n")
                for typo in formatted_typos:
                    file.write(f"{typo}\n")
            else:
                for typo in formatted_typos:
                    file.write(f"{typo}\n")
        logging.info(f"Successfully generated {len(formatted_typos)} synthetic typos and saved to '{output_file}'.")
    except Exception as e:
        logging.error(f"Error writing to '{output_file}': {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
