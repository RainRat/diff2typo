import sys
import argparse
import yaml
import logging
import time
from collections import defaultdict
from types import SimpleNamespace
from typing import Any, Iterable, Mapping, MutableMapping, Sequence, Set
from tqdm import tqdm  # For progress bars; install via `pip install tqdm`


DEFAULT_CONFIG: dict[str, Any] = {
    'typo_types': {
        'deletion': True,
        'transposition': True,
        'replacement': True,
        'duplication': True,
    },
    'word_length': {
        'min_length': 8,
        'max_length': None,
    },
    'output_header': None,
}


def _merge_defaults(
    config: MutableMapping[str, Any],
    defaults: Mapping[str, Any],
    path: list[str] | None = None,
) -> None:
    """Recursively merge default configuration values into the provided config."""

    if path is None:
        path = []

    for key, default_value in defaults.items():
        dotted_path = '.'.join(path + [key])
        if isinstance(default_value, dict):
            existing = config.setdefault(key, {})
            if not isinstance(existing, dict):
                logging.error(f"Configuration value for '{dotted_path}' must be a mapping.")
                sys.exit(1)
            _merge_defaults(existing, default_value, path + [key])
        else:
            if key not in config:
                logging.info(f"Applying default for '{dotted_path}': {default_value}")
            config.setdefault(key, default_value)

def get_adjacent_keys(include_diagonals: bool = True) -> dict[str, set[str]]:
    """
    Returns a dictionary of adjacent keys on a QWERTY keyboard.
    Can include diagonally adjacent keys based on the 'include_diagonals' flag.

    Args:
        include_diagonals (bool): Whether to include diagonally adjacent keys.

    Returns:
        dict: A mapping from each character to its adjacent characters.
    """
    keyboard = [
        'qwertyuiop',
        'asdfghjkl',
        'zxcvbnm',
    ]

    # Map each character to its (row, column) coordinate for quick lookup
    coords: dict[str, tuple[int, int]] = {}
    for r, row in enumerate(keyboard):
        for c, ch in enumerate(row):
            coords[ch] = (r, c)

    adjacent: dict[str, set[str]] = {ch: set() for ch in coords}

    for ch, (r, c) in coords.items():
        # Examine neighbouring positions within a 1-key radius
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue  # Skip the key itself

                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= len(keyboard):
                    continue
                if nc < 0 or nc >= len(keyboard[nr]):
                    continue

                # Exclude diagonal keys if requested
                if not include_diagonals and dr != 0 and dc != 0:
                    continue

                adjacent_char = keyboard[nr][nc]
                adjacent[ch].add(adjacent_char)

    return adjacent


def load_custom_substitutions(
    custom_subs: Mapping[str, Iterable[str]] | None,
) -> dict[str, set[str]]:
    """
    Load custom substitution rules from a dictionary.

    Args:
        custom_subs (dict): Dictionary containing custom substitution rules.

    Returns:
        dict: A dictionary with characters as keys and sets of substitution characters as values.
    """
    if not custom_subs:
        return {}
    # Ensure all keys and values are lowercase
    substitutions = {k.lower(): set(vv.lower() for vv in v) for k, v in custom_subs.items()}
    return substitutions


def generate_typos_by_replacement(
    word: str,
    adjacent_keys: Mapping[str, Set[str]],
    custom_subs: Mapping[str, Set[str]] | None = None,
    use_adjacent: bool = True,
    use_custom: bool = True,
) -> set[str]:
    """
    Generate typos by replacing each character with its adjacent keys and/or custom substitutions.

    Args:
        word (str): The input word.
        adjacent_keys (dict): Mapping of each character to its adjacent keys.
        custom_subs (dict, optional): Custom substitution rules.
        use_adjacent (bool): Whether to include adjacent key substitutions.
        use_custom (bool): Whether to include custom substitutions.

    Returns:
        set: A set of typo variations generated by replacement.
    """
    typos = set()

    for i, char in enumerate(word):
        replacement_chars = set()

        # Adjacent key replacements
        if use_adjacent and char in adjacent_keys:
            replacement_chars.update(adjacent_keys[char])

        # Custom substitutions
        if use_custom and custom_subs and char in custom_subs:
            replacement_chars.update(custom_subs[char])

        for replace_char in replacement_chars:
            typo = word[:i] + replace_char + word[i+1:]
            typos.add(typo)

    return typos


def generate_variations(
    word: str, typo_types: Mapping[str, bool], transposition_distance: int = 1
) -> set[str]:
    """
    Generate deletion and transposition typos.

    Args:
        word (str): The input word.
        typo_types (dict): Dictionary indicating which typo types to apply.

    Returns:
        set: A set of typo variations from deletion and transposition.
    """
    variations = set()

    # Deletion
    if typo_types.get('deletion', False):
        for i in range(len(word)):
            # Don't remove 's' or 'd' from the end of the word
            if i == len(word) - 1 and word[i] in {'s', 'd'}:
                continue
            variation = word[:i] + word[i + 1:]
            variations.add(variation)

    # Transposition
    if typo_types.get('transposition', False):
        distance = max(1, transposition_distance)
        for i in range(len(word) - distance):
            if word[i] == word[i + distance]:
                continue  # Don't swap identical letters
            # Swap characters that are 'distance' apart
            middle = word[i + 1:i + distance]
            variation = word[:i] + word[i + distance] + middle + word[i] + word[i + distance + 1:]
            variations.add(variation)

    return variations


def generate_typos_by_duplication(word: str) -> set[str]:
    """
    Generate typos by duplicating each character in the word.

    Args:
        word (str): The input word.

    Returns:
        set: A set of typo variations generated by duplication.
    """
    typos = set()

    for i in range(len(word)):
        duplicated_char = word[i]
        typo = word[:i+1] + duplicated_char + word[i+1:]
        typos.add(typo)

    return typos


def generate_all_typos(
    word: str,
    adjacent_keys: Mapping[str, Set[str]],
    custom_subs: Mapping[str, Set[str]],
    typo_types: Mapping[str, bool],
    transposition_distance: int = 1,
    use_adjacent: bool = True,
    use_custom: bool = True,
) -> set[str]:
    """
    Generate all possible typos for a given word using selected typo types.

    Args:
        word (str): The input word.
        adjacent_keys (dict): Mapping of each character to its adjacent keys.
        custom_subs (dict): Custom substitution rules.
        typo_types (dict): Dictionary indicating which typo types to apply.
        transposition_distance (int): Distance between letters to swap for transposition typos.
        use_adjacent (bool): Whether to include adjacent key substitutions.
        use_custom (bool): Whether to include custom substitutions.

    Returns:
        set: A set of all unique typo variations.
    """
    typos = set()

    # Deletion and Transposition
    typos.update(generate_variations(word, typo_types, transposition_distance))

    # Replacement
    if typo_types.get('replacement', False):
        typos.update(
            generate_typos_by_replacement(
                word,
                adjacent_keys,
                custom_subs,
                use_adjacent,
                use_custom,
            )
        )

    # Duplication
    if typo_types.get('duplication', False):
        typos.update(generate_typos_by_duplication(word))

    return typos


def load_file(file_path: str) -> set[str]:
    """
    Generic function to load words from a file into a set.
    Filters out non-ASCII words and converts them to lowercase.

    Args:
        file_path (str): Path to the file containing words.

    Returns:
        set: A set of cleaned words.
    """
    try:
        words = set()
        with open(file_path, 'r', encoding='utf-8') as file:
            for line in file:
                line = line.strip()
                if line and all(ord(c) < 128 for c in line):
                    words.add(line.lower())
        logging.debug(f"Loaded {len(words)} unique words from '{file_path}'.")
        return words
    except FileNotFoundError:
        logging.error(f"File '{file_path}' not found.")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Error reading '{file_path}': {e}")
        sys.exit(1)


def parse_yaml_config(config_path: str) -> dict[str, Any]:
    """
    Parse the YAML configuration file.

    Args:
        config_path (str): Path to the YAML configuration file.

    Returns:
        dict: Parsed configuration.
    """
    try:
        with open(config_path, 'r', encoding='utf-8') as file:
            config = yaml.safe_load(file)
            logging.debug(f"Parsed YAML configuration from '{config_path}'.")
            return config
    except FileNotFoundError:
        logging.error(f"Configuration file '{config_path}' not found.")
        sys.exit(1)
    except yaml.YAMLError as e:
        logging.error(f"Error parsing YAML file '{config_path}': {e}")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Error reading '{config_path}': {e}")
        sys.exit(1)


def validate_config(config: MutableMapping[str, Any]) -> None:
    """
    Validate the YAML configuration to ensure all required fields are present.

    Args:
        config (dict): Parsed YAML configuration.
    """
    required_fields = ['input_file', 'dictionary_file', 'output_file', 'output_format']
    for field in required_fields:
        if field not in config:
            logging.error(f"Missing required configuration field: '{field}'")
            sys.exit(1)

    if 'typo_types' in config and not isinstance(config['typo_types'], dict):
        logging.error("Configuration field 'typo_types' must be a mapping.")
        sys.exit(1)

    if 'word_length' in config and not isinstance(config['word_length'], dict):
        logging.error("Configuration field 'word_length' must be a mapping.")
        sys.exit(1)

    _merge_defaults(config, DEFAULT_CONFIG)


def format_typos(
    typo_to_correct_word: Mapping[str, str], output_format: str
) -> list[str]:
    """
    Formats the typos based on the specified output format.

    Args:
        typo_to_correct_word (dict): Mapping from typo to correct word.
        output_format (str): Desired output format ('arrow', 'csv', 'table', 'list').

    Returns:
        list: Formatted list of typo strings.
    """
    formatted = []
    for typo, correct_word in typo_to_correct_word.items():
        if output_format == 'arrow':
            formatted.append(f"{typo} -> {correct_word}")
        elif output_format == 'csv':
            formatted.append(f"{typo},{correct_word}")
        elif output_format == 'table':
            formatted.append(f'{typo} = "{correct_word}"')
        elif output_format == 'list':
            formatted.append(f"{typo}")
    return formatted


def _extract_config_settings(config: MutableMapping[str, Any], quiet: bool = False) -> SimpleNamespace:
    """Extract validated configuration values into a structured namespace."""

    input_file = config.get('input_file', 'wordlist_small.txt')
    dictionary_file = config.get('dictionary_file', 'wordlist_large.txt')
    output_file = config.get('output_file', 'typos_mega.toml')
    output_format = config.get('output_format', 'table').lower()
    output_header = config.get('output_header')

    valid_formats = {'arrow', 'csv', 'table', 'list'}
    if output_format not in valid_formats:
        logging.warning(
            f"Unknown output format '{output_format}'. Defaulting to 'arrow'."
        )
        output_format = 'arrow'

    if output_header is None and output_format == 'table':
        output_header = "[default.extend-words]"

    replacement_options = config.get(
        'replacement_options',
        {
            'include_diagonals': True,
            'enable_adjacent_substitutions': True,
            'enable_custom_substitutions': True,
        },
    )
    include_diagonals = replacement_options.get('include_diagonals', True)
    enable_adjacent_substitutions = replacement_options.get(
        'enable_adjacent_substitutions', True
    )
    enable_custom_substitutions = replacement_options.get(
        'enable_custom_substitutions', True
    )

    transposition_options = config.get('transposition_options', {'distance': 1})
    transposition_distance = transposition_options.get('distance', 1)

    repeat_modifications = int(config.get('repeat_modifications', 1))
    repeat_modifications = max(1, repeat_modifications)

    word_length = config.get('word_length', {'min_length': 8, 'max_length': None})
    min_length = word_length.get('min_length', 8)
    max_length = word_length.get('max_length', None)

    settings = SimpleNamespace(
        input_file=input_file,
        dictionary_file=dictionary_file,
        output_file=output_file,
        output_format=output_format,
        output_header=output_header,
        typo_types=config['typo_types'],
        include_diagonals=include_diagonals,
        enable_adjacent_substitutions=enable_adjacent_substitutions,
        enable_custom_substitutions=enable_custom_substitutions,
        transposition_distance=transposition_distance,
        repeat_modifications=repeat_modifications,
        min_length=min_length,
        max_length=max_length,
        custom_substitutions_config=config.get('custom_substitutions', {}),
        quiet=quiet,
    )

    return settings


def _setup_generation_tools(
    settings: SimpleNamespace,
) -> tuple[dict[str, set[str]], dict[str, set[str]]]:
    """Prepare substitution helpers based on configuration settings."""

    logging.info("Loading custom substitutions...")
    if not settings.enable_custom_substitutions:
        logging.info("Custom substitutions disabled.")
        custom_subs = {}
    else:
        custom_subs = load_custom_substitutions(settings.custom_substitutions_config)
        if custom_subs:
            total_custom_entries = len(custom_subs)
            total_custom_replacements = sum(len(v) for v in custom_subs.values())
            logging.info(
                "Loaded %d custom substitution entries with a total of %d replacements.",
                total_custom_entries,
                total_custom_replacements,
            )
        else:
            logging.info("No custom substitutions loaded.")

    if settings.enable_adjacent_substitutions:
        logging.info("Generating adjacent keys mapping...")
        adjacent_keys = get_adjacent_keys(settings.include_diagonals)
        total_adjacent_mappings = len(adjacent_keys)

        adjacent_substitutions = set()
        for char, adj_set in adjacent_keys.items():
            for adj_char in adj_set:
                adjacent_substitutions.add((char, adj_char))
        total_adjacent_substitutions = len(adjacent_substitutions)
        logging.info(
            "Generated adjacent keys for %d characters with %d unique adjacent substitutions (non-reflexive).",
            total_adjacent_mappings,
            total_adjacent_substitutions,
        )
    else:
        adjacent_keys = {}
        logging.info("Adjacent substitutions disabled.")

    return adjacent_keys, custom_subs


def _run_typo_generation(
    word_list: Sequence[str],
    all_words: set[str],
    settings: SimpleNamespace,
    adjacent_keys: Mapping[str, Set[str]],
    custom_subs: Mapping[str, Set[str]],
    quiet: bool = False,
) -> dict[str, str]:
    """Generate, filter, and sort typos based on the provided settings."""

    logging.info("Generating synthetic typos...")
    typo_to_correct_word = defaultdict(list)

    for word in tqdm(word_list, desc="Processing words", disable=quiet):
        word_len = len(word)
        if word_len < settings.min_length:
            continue
        if settings.max_length and word_len > settings.max_length:
            continue

        typos_current = {word}
        accumulated_typos = set()
        for _ in range(settings.repeat_modifications):
            new_typos = set()
            for base_word in typos_current:
                new_typos.update(
                    generate_all_typos(
                        base_word,
                        adjacent_keys,
                        custom_subs,
                        settings.typo_types,
                        settings.transposition_distance,
                        settings.enable_adjacent_substitutions,
                        settings.enable_custom_substitutions,
                    )
                )
            accumulated_typos.update(new_typos)
            typos_current = new_typos
        for typo in accumulated_typos:
            typo_to_correct_word[typo].append(word)

    total_typos_generated = len(typo_to_correct_word)
    logging.info(
        "Generated %d unique synthetic typos before filtering.", total_typos_generated
    )

    logging.info("Filtering typos against the large dictionary...")
    filter_start_time = time.perf_counter()
    filtered_typo_to_correct_word = {}
    filtered_typos_count = 0

    for typo, correct_words in typo_to_correct_word.items():
        if typo in all_words:
            filtered_typos_count += 1
            logging.debug(
                "Filtered out typo '%s' as it exists in the large dictionary.", typo
            )
            continue
        filtered_typo_to_correct_word[typo] = ', '.join(correct_words)

    final_typo_count = len(filtered_typo_to_correct_word)
    filter_duration = time.perf_counter() - filter_start_time
    logging.info(
        "After filtering, %d typos remain (filtered out %d typos) in %.2f seconds.",
        final_typo_count,
        filtered_typos_count,
        filter_duration,
    )

    sorted_typos = sorted(filtered_typo_to_correct_word.items())
    return dict(sorted_typos)


def main() -> None:
    """
    Main function to generate synthetic typos and save them to a file based on YAML configuration.
    """
    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description="Synthetic Typo Generator: Generate synthetic typos for a list of words based on YAML configuration."
    )
    parser.add_argument(
        '-c', '--config',
        type=str,
        default="gentypos.yaml",
        help="Path to the YAML configuration file (default: gentypos.yaml)"
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help="Enable verbose output.",
    )
    parser.add_argument(
        '-q', '--quiet',
        action='store_true',
        help="Suppress progress bars and reduce log verbosity.",
    )
    args = parser.parse_args()

    log_level = logging.DEBUG if args.verbose else logging.WARNING if args.quiet else logging.INFO
    logging.basicConfig(level=log_level, format='%(asctime)s - %(levelname)s - %(message)s')
    if args.verbose:
        logging.debug("Verbose mode enabled.")
    elif args.quiet:
        logging.debug("Quiet mode enabled.")

    # Load configuration
    config = parse_yaml_config(args.config)

    # Validate configuration
    validate_config(config)

    settings = _extract_config_settings(config, quiet=args.quiet)

    # Load words and dictionary using the modified load_file function
    logging.info("Loading wordlist (small dictionary)...")
    word_set = load_file(settings.input_file)
    word_list = list(word_set)  # Convert set to list if needed
    logging.info(
        "Loaded %d words from the small dictionary ('%s').",
        len(word_list),
        settings.input_file,
    )

    logging.info("Loading dictionary (large dictionary)...")
    all_words = load_file(settings.dictionary_file)
    logging.info(
        "Loaded %d words from the large dictionary ('%s').",
        len(all_words),
        settings.dictionary_file,
    )

    adjacent_keys, custom_subs = _setup_generation_tools(settings)

    sorted_typo_dict = _run_typo_generation(
        word_list,
        all_words,
        settings,
        adjacent_keys,
        custom_subs,
        quiet=settings.quiet,
    )

    # Format typos based on the selected output format
    logging.info("Formatting typos in '%s' format...", settings.output_format)
    formatted_typos = format_typos(sorted_typo_dict, settings.output_format)

    # Write to output file
    try:
        with open(settings.output_file, 'w', encoding='utf-8') as file:
            if settings.output_header:
                file.write(settings.output_header + "\n")
            for typo in formatted_typos:
                file.write(f"{typo}\n")
        logging.info(
            "Successfully generated %d synthetic typos and saved to '%s'.",
            len(formatted_typos),
            settings.output_file,
        )
    except Exception as e:
        logging.error("Error writing to '%s': %s", settings.output_file, e)
        sys.exit(1)


if __name__ == "__main__":
    main()
