import sys
import argparse
import yaml
import logging
import time
from collections import defaultdict
from types import SimpleNamespace
from tqdm import tqdm  # For progress bars; install via `pip install tqdm`


DEFAULT_CONFIG = {
    'typo_types': {
        'deletion': True,
        'transposition': True,
        'replacement': True,
        'duplication': True,
    },
    'word_length': {
        'min_length': 8,
        'max_length': None,
    },
    'output_header': None,
}


def _merge_defaults(config, defaults, path=None):
    """Recursively merge default configuration values into the provided config."""

    if path is None:
        path = []

    for key, default_value in defaults.items():
        dotted_path = '.'.join(path + [key])
        if isinstance(default_value, dict):
            existing = config.setdefault(key, {})
            if not isinstance(existing, dict):
                logging.error(f"Configuration value for '{dotted_path}' must be a mapping.")
                sys.exit(1)
            _merge_defaults(existing, default_value, path + [key])
        else:
            if key not in config:
                logging.info(f"Applying default for '{dotted_path}': {default_value}")
            config.setdefault(key, default_value)

def get_adjacent_keys(include_diagonals=True):
    """
    Returns a dictionary of adjacent keys on a QWERTY keyboard.
    Can include diagonally adjacent keys based on the 'include_diagonals' flag.

    Args:
        include_diagonals (bool): Whether to include diagonally adjacent keys.

    Returns:
        dict: A mapping from each character to its adjacent characters.
    """
    keyboard = [
        'qwertyuiop',
        'asdfghjkl',
        'zxcvbnm',
    ]

    # Map each character to its (row, column) coordinate for quick lookup
    coords = {}
    for r, row in enumerate(keyboard):
        for c, ch in enumerate(row):
            coords[ch] = (r, c)

    adjacent = {ch: set() for ch in coords}

    for ch, (r, c) in coords.items():
        # Examine neighbouring positions within a 1-key radius
        for dr in (-1, 0, 1):
            for dc in (-1, 0, 1):
                if dr == 0 and dc == 0:
                    continue  # Skip the key itself

                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= len(keyboard):
                    continue
                if nc < 0 or nc >= len(keyboard[nr]):
                    continue

                # Exclude diagonal keys if requested
                if not include_diagonals and dr != 0 and dc != 0:
                    continue

                adjacent_char = keyboard[nr][nc]
                adjacent[ch].add(adjacent_char)

    return adjacent


def load_custom_substitutions(custom_subs):
    """
    Load custom substitution rules from a dictionary.

    Args:
        custom_subs (dict): Dictionary containing custom substitution rules.

    Returns:
        dict: A dictionary with characters as keys and sets of substitution characters as values.
    """
    if not custom_subs:
        return {}
    # Ensure all keys and values are lowercase
    substitutions = {k.lower(): set(vv.lower() for vv in v) for k, v in custom_subs.items()}
    return substitutions


def generate_typos_by_replacement(word, adjacent_keys, custom_subs=None,
                                  use_adjacent=True, use_custom=True):
    """
    Generate typos by replacing each character with its adjacent keys and/or custom substitutions.

    Args:
        word (str): The input word.
        adjacent_keys (dict): Mapping of each character to its adjacent keys.
        custom_subs (dict, optional): Custom substitution rules.
        use_adjacent (bool): Whether to include adjacent key substitutions.
        use_custom (bool): Whether to include custom substitutions.

    Returns:
        set: A set of typo variations generated by replacement.
    """
    typos = set()

    for i, char in enumerate(word):
        replacement_chars = set()

        # Adjacent key replacements
        if use_adjacent and char in adjacent_keys:
            replacement_chars.update(adjacent_keys[char])

        # Custom substitutions
        if use_custom and custom_subs and char in custom_subs:
            replacement_chars.update(custom_subs[char])

        for replace_char in replacement_chars:
            typo = word[:i] + replace_char + word[i+1:]
            typos.add(typo)

    return typos


def generate_variations(word, typo_types, transposition_distance=1):
    """
    Generate deletion and transposition typos.

    Args:
        word (str): The input word.
        typo_types (dict): Dictionary indicating which typo types to apply.

    Returns:
        set: A set of typo variations from deletion and transposition.
    """
    variations = set()

    # Deletion
    if typo_types.get('deletion', False):
        for i in range(len(word)):
            # Don't remove 's' or 'd' from the end of the word
            if i == len(word) - 1 and word[i] in {'s', 'd'}:
                continue
            variation = word[:i] + word[i + 1:]
            variations.add(variation)

    # Transposition
    if typo_types.get('transposition', False):
        distance = max(1, transposition_distance)
        for i in range(len(word) - distance):
            if word[i] == word[i + distance]:
                continue  # Don't swap identical letters
            # Swap characters that are 'distance' apart
            middle = word[i + 1:i + distance]
            variation = word[:i] + word[i + distance] + middle + word[i] + word[i + distance + 1:]
            variations.add(variation)

    return variations


def generate_typos_by_duplication(word, typo_types):
    """
    Generate typos by duplicating each character in the word.

    Args:
        word (str): The input word.
        typo_types (dict): Dictionary indicating which typo types to apply.

    Returns:
        set: A set of typo variations generated by duplication.
    """
    typos = set()

    if typo_types.get('duplication', False):
        for i in range(len(word)):
            duplicated_char = word[i]
            typo = word[:i+1] + duplicated_char + word[i+1:]
            typos.add(typo)

    return typos


def generate_all_typos(word, adjacent_keys, custom_subs, typo_types,
                       transposition_distance=1, use_adjacent=True,
                       use_custom=True):
    """
    Generate all possible typos for a given word using selected typo types.

    Args:
        word (str): The input word.
        adjacent_keys (dict): Mapping of each character to its adjacent keys.
        custom_subs (dict): Custom substitution rules.
        typo_types (dict): Dictionary indicating which typo types to apply.
        transposition_distance (int): Distance between letters to swap for transposition typos.
        use_adjacent (bool): Whether to include adjacent key substitutions.
        use_custom (bool): Whether to include custom substitutions.

    Returns:
        set: A set of all unique typo variations.
    """
    typos = set()

    # Deletion and Transposition
    typos.update(generate_variations(word, typo_types, transposition_distance))

    # Replacement
    if typo_types.get('replacement', False):
        typos.update(
            generate_typos_by_replacement(
                word,
                adjacent_keys,
                custom_subs,
                use_adjacent,
                use_custom,
            )
        )

    # Duplication
    if typo_types.get('duplication', False):
        typos.update(generate_typos_by_duplication(word, typo_types))

    return typos


def load_file(file_path):
    """
    Generic function to load words from a file into a set.
    Filters out non-ASCII words and converts them to lowercase.

    Args:
        file_path (str): Path to the file containing words.

    Returns:
        set: A set of cleaned words.
    """
    try:
        words = set()
        with open(file_path, 'r', encoding='utf-8') as file:
            for line in file:
                line = line.strip()
                if line and all(ord(c) < 128 for c in line):
                    words.add(line.lower())
        logging.debug(f"Loaded {len(words)} unique words from '{file_path}'.")
        return words
    except FileNotFoundError:
        logging.error(f"File '{file_path}' not found.")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Error reading '{file_path}': {e}")
        sys.exit(1)


def parse_yaml_config(config_path):
    """
    Parse the YAML configuration file.

    Args:
        config_path (str): Path to the YAML configuration file.

    Returns:
        dict: Parsed configuration.
    """
    try:
        with open(config_path, 'r', encoding='utf-8') as file:
            config = yaml.safe_load(file)
            logging.debug(f"Parsed YAML configuration from '{config_path}'.")
            return config
    except FileNotFoundError:
        logging.error(f"Configuration file '{config_path}' not found.")
        sys.exit(1)
    except yaml.YAMLError as e:
        logging.error(f"Error parsing YAML file '{config_path}': {e}")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Error reading '{config_path}': {e}")
        sys.exit(1)


def validate_config(config):
    """
    Validate the YAML configuration to ensure all required fields are present.

    Args:
        config (dict): Parsed YAML configuration.
    """
    required_fields = ['input_file', 'dictionary_file', 'output_file', 'output_format']
    for field in required_fields:
        if field not in config:
            logging.error(f"Missing required configuration field: '{field}'")
            sys.exit(1)

    if 'typo_types' in config and not isinstance(config['typo_types'], dict):
        logging.error("Configuration field 'typo_types' must be a mapping.")
        sys.exit(1)

    if 'word_length' in config and not isinstance(config['word_length'], dict):
        logging.error("Configuration field 'word_length' must be a mapping.")
        sys.exit(1)

    _merge_defaults(config, DEFAULT_CONFIG)


def format_typos(typo_to_correct_word, output_format):
    """
    Formats the typos based on the specified output format.

    Args:
        typo_to_correct_word (dict): Mapping from typo to correct word.
        output_format (str): Desired output format ('arrow', 'csv', 'table', 'list').

    Returns:
        list: Formatted list of typo strings.
    """
    formatted = []
    for typo, correct_word in typo_to_correct_word.items():
        if output_format == 'arrow':
            formatted.append(f"{typo} -> {correct_word}")
        elif output_format == 'csv':
            formatted.append(f"{typo},{correct_word}")
        elif output_format == 'table':
            formatted.append(f'{typo} = "{correct_word}"')
        elif output_format == 'list':
            formatted.append(f"{typo}")
        else:
            # Default to arrow if unknown format
            formatted.append(f"{typo} -> {correct_word}")
    return formatted


def _extract_config_settings(config):
    """Extract validated configuration values into a structured namespace."""

    input_file = config.get('input_file', 'wordlist_small.txt')
    dictionary_file = config.get('dictionary_file', 'wordlist_large.txt')
    output_file = config.get('output_file', 'typos_mega.toml')
    output_format = config.get('output_format', 'table').lower()
    output_header = config.get('output_header')

    valid_formats = {'arrow', 'csv', 'table', 'list'}
    if output_format not in valid_formats:
        logging.warning(
            f"Unknown output format '{output_format}'. Defaulting to 'arrow'."
        )
        output_format = 'arrow'

    if output_header is None and output_format == 'table':
        output_header = "[default.extend-words]"

    replacement_options = config.get(
        'replacement_options',
        {
            'include_diagonals': True,
            'enable_adjacent_substitutions': True,
            'enable_custom_substitutions': True,
        },
    )
    include_diagonals = replacement_options.get('include_diagonals', True)
    enable_adjacent_substitutions = replacement_options.get(
        'enable_adjacent_substitutions', True
    )
    enable_custom_substitutions = replacement_options.get(
        'enable_custom_substitutions', True
    )

    transposition_options = config.get('transposition_options', {'distance': 1})
    transposition_distance = transposition_options.get('distance', 1)

    repeat_modifications = int(config.get('repeat_modifications', 1))
    repeat_modifications = max(1, repeat_modifications)

    word_length = config.get('word_length', {'min_length': 8, 'max_length': None})
    min_length = word_length.get('min_length', 8)
    max_length = word_length.get('max_length', None)

    settings = SimpleNamespace(
        input_file=input_file,
        dictionary_file=dictionary_file,
        output_file=output_file,
        output_format=output_format,
        output_header=output_header,
        typo_types=config['typo_types'],
        include_diagonals=include_diagonals,
        enable_adjacent_substitutions=enable_adjacent_substitutions,
        enable_custom_substitutions=enable_custom_substitutions,
        transposition_distance=transposition_distance,
        repeat_modifications=repeat_modifications,
        min_length=min_length,
        max_length=max_length,
        custom_substitutions_config=config.get('custom_substitutions', {}),
    )

    return settings


def _setup_generation_tools(settings):
    """Prepare substitution helpers based on configuration settings."""

    logging.info("Loading custom substitutions...")
    if not settings.enable_custom_substitutions:
        logging.info("Custom substitutions disabled.")
        custom_subs = {}
    else:
        custom_subs = load_custom_substitutions(settings.custom_substitutions_config)
        if custom_subs:
            total_custom_entries = len(custom_subs)
            total_custom_replacements = sum(len(v) for v in custom_subs.values())
            logging.info(
                "Loaded %d custom substitution entries with a total of %d replacements.",
                total_custom_entries,
                total_custom_replacements,
            )
        else:
            logging.info("No custom substitutions loaded.")

    if settings.enable_adjacent_substitutions:
        logging.info("Generating adjacent keys mapping...")
        adjacent_keys = get_adjacent_keys(settings.include_diagonals)
        total_adjacent_mappings = len(adjacent_keys)

        adjacent_substitutions = set()
        for char, adj_set in adjacent_keys.items():
            for adj_char in adj_set:
                adjacent_substitutions.add((char, adj_char))
        total_adjacent_substitutions = len(adjacent_substitutions)
        logging.info(
            "Generated adjacent keys for %d characters with %d unique adjacent substitutions (non-reflexive).",
            total_adjacent_mappings,
            total_adjacent_substitutions,
        )
    else:
        adjacent_keys = {}
        logging.info("Adjacent substitutions disabled.")

    return adjacent_keys, custom_subs


def _run_typo_generation(word_list, all_words, settings, adjacent_keys, custom_subs):
    """Generate, filter, and sort typos based on the provided settings."""

    logging.info("Generating synthetic typos...")
    typo_to_correct_word = defaultdict(list)

    for word in tqdm(word_list, desc="Processing words"):
        word_len = len(word)
        if word_len < settings.min_length:
            continue
        if settings.max_length and word_len > settings.max_length:
            continue

        typos_current = {word}
        accumulated_typos = set()
        for _ in range(settings.repeat_modifications):
            new_typos = set()
            for base_word in typos_current:
                new_typos.update(
                    generate_all_typos(
                        base_word,
                        adjacent_keys,
                        custom_subs,
                        settings.typo_types,
                        settings.transposition_distance,
                        settings.enable_adjacent_substitutions,
                        settings.enable_custom_substitutions,
                    )
                )
            accumulated_typos.update(new_typos)
            typos_current = new_typos
        for typo in accumulated_typos:
            typo_to_correct_word[typo].append(word)

    total_typos_generated = len(typo_to_correct_word)
    logging.info(
        "Generated %d unique synthetic typos before filtering.", total_typos_generated
    )

    logging.info("Filtering typos against the large dictionary...")
    filter_start_time = time.perf_counter()
    filtered_typo_to_correct_word = {}
    filtered_typos_count = 0

    for typo, correct_words in typo_to_correct_word.items():
        if typo in all_words:
            filtered_typos_count += 1
            logging.debug(
                "Filtered out typo '%s' as it exists in the large dictionary.", typo
            )
            continue
        filtered_typo_to_correct_word[typo] = ', '.join(correct_words)

    final_typo_count = len(filtered_typo_to_correct_word)
    filter_duration = time.perf_counter() - filter_start_time
    logging.info(
        "After filtering, %d typos remain (filtered out %d typos) in %.2f seconds.",
        final_typo_count,
        filtered_typos_count,
        filter_duration,
    )

    sorted_typos = sorted(filtered_typo_to_correct_word.items())
    return dict(sorted_typos)


def main():
    """
    Main function to generate synthetic typos and save them to a file based on YAML configuration.
    """
    # Configure logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    # Parse command-line arguments
    parser = argparse.ArgumentParser(
        description="Synthetic Typo Generator: Generate synthetic typos for a list of words based on YAML configuration."
    )
    parser.add_argument(
        '-c', '--config',
        type=str,
        default="gentypos.yaml",
        help="Path to the YAML configuration file (default: gentypos.yaml)"
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help="Enable verbose output."
    )
    args = parser.parse_args()

    # Set logging level based on verbose flag
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        logging.debug("Verbose mode enabled.")

    # Load configuration
    config = parse_yaml_config(args.config)

    # Validate configuration
    validate_config(config)

    settings = _extract_config_settings(config)

    # Load words and dictionary using the modified load_file function
    logging.info("Loading wordlist (small dictionary)...")
    word_set = load_file(settings.input_file)
    word_list = list(word_set)  # Convert set to list if needed
    logging.info(
        "Loaded %d words from the small dictionary ('%s').",
        len(word_list),
        settings.input_file,
    )

    logging.info("Loading dictionary (large dictionary)...")
    all_words = set(load_file(settings.dictionary_file))
    logging.info(
        "Loaded %d words from the large dictionary ('%s').",
        len(all_words),
        settings.dictionary_file,
    )

    adjacent_keys, custom_subs = _setup_generation_tools(settings)

    sorted_typo_dict = _run_typo_generation(
        word_list,
        all_words,
        settings,
        adjacent_keys,
        custom_subs,
    )

    # Format typos based on the selected output format
    logging.info("Formatting typos in '%s' format...", settings.output_format)
    formatted_typos = format_typos(sorted_typo_dict, settings.output_format)

    # Write to output file
    try:
        with open(settings.output_file, 'w', encoding='utf-8') as file:
            if settings.output_header:
                file.write(settings.output_header + "\n")
            for typo in formatted_typos:
                file.write(f"{typo}\n")
        logging.info(
            "Successfully generated %d synthetic typos and saved to '%s'.",
            len(formatted_typos),
            settings.output_file,
        )
    except Exception as e:
        logging.error("Error writing to '%s': %s", settings.output_file, e)
        sys.exit(1)


if __name__ == "__main__":
    main()
